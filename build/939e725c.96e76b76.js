(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{117:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return d}));var a=t(1),r=t(6),i=(t(0),t(135)),c={id:"framework-dependencies",title:"Dependencies",sidebar_label:"Dependencies"},o={id:"framework-dependencies",title:"Dependencies",description:"Dependency management is done through the service container in the same way as in other frameworks. This allows to perform dependency injection and bind interfaces to implementations or class constructors to existing instances.\r",source:"@site/docs\\dependencies.md",permalink:"/docs/framework-dependencies",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/dependencies.md",sidebar_label:"Dependencies",sidebar:"someSidebar",previous:{title:"Autoloader",permalink:"/docs/framework-autoloader"},next:{title:"Plugins",permalink:"/docs/framework-plugin-manager"}},s=[{value:"The Container",id:"the-container",children:[]},{value:"Dependency Injection",id:"dependency-injection",children:[]},{value:"Make Method",id:"make-method",children:[{value:"Basic Usage",id:"basic-usage",children:[]},{value:"Passing Arguments",id:"passing-arguments",children:[]},{value:"Shortcut Method",id:"shortcut-method",children:[]}]},{value:"Container Bindings",id:"container-bindings",children:[{value:"Closure Binding",id:"closure-binding",children:[]},{value:"Singleton Binding",id:"singleton-binding",children:[]},{value:"Instance Binding",id:"instance-binding",children:[]},{value:"Interface Binding",id:"interface-binding",children:[]}]},{value:"Container Actions",id:"container-actions",children:[{value:"Create Action on('create', 'method', 'bla')",id:"create-action-oncreate-method-bla",children:[]},{value:"Resolve Action on('resolve', 'method', 'bla')",id:"resolve-action-onresolve-method-bla",children:[]}]}],l={rightToc:s};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Dependency management is done through the service container in the same way as in other frameworks. This allows to perform dependency injection and bind interfaces to implementations or class constructors to existing instances."),Object(i.b)("h2",{id:"the-container"},"The Container"),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"Container")," is usually referenced as the ",Object(i.b)("strong",{parentName:"p"},"Service Container"),", as it's usually used to inject or bind services to the controllers. An instance of the Container is stored in the core ",Object(i.b)("strong",{parentName:"p"},"Sci")," class. You can access the container and all of the methods it includes by just using the ",Object(i.b)("inlineCode",{parentName:"p"},"container")," method of the ",Object(i.b)("strong",{parentName:"p"},"Sci")," class:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\n\n# Get Sci instance\n$sci = Sci::instance();\n\n# Get container instance\n$container = $sci->container();\n")),Object(i.b)("p",null,"After getting the container instance you will be able to use all the included methods, covered in this section. However, let's learn first an important concept."),Object(i.b)("h2",{id:"dependency-injection"},"Dependency Injection"),Object(i.b)("p",null,"The SCIWP Framework container allows to define dependencies in class constructor so the instances of the required dependencies are automatically created. If you are used to use ",Object(i.b)("strong",{parentName:"p"},"Dependency Injection (DI)")," with other frameworks, then this is exactly the same. However, if you are new, it's worth to check this example, as it's easier than it sounds:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"\nnamespace MyPlugin\\App\\Controllers;\n\nuse MyPlugin\\Sci\\Controller;\nuse MyPlugin\\App\\Services\\CarManager;\n\nclass CarController extends Controller\n{\n    # Will contain the CarManager instance\n    protected $carManager;\n\n    # We use type in the CarManager dependency\n    public function __construct(CarManager $carManager)\n    {\n        # The CarManager instance is already created\n        $this->carManager = $carManager;\n    }\n\n    # Use the CarManager to get a car\n    public function getCar($carId)\n    {\n        $car = $this->carManager->get($carId);\n        return $car;\n    }\n}\n")),Object(i.b)("p",null,"In the previous example we don't need to create a new instance of the CarManager, as we already injected it in as an argument. But how can this happen? the trick is in the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," method of the Container class, which is called in teh background. This controller is probably the endpoint of a route which creates an instance of this controller with the make method."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Route;\n\nRoute::get('/cars/{carId}', 'MyPlugin\\App\\Controllers\\CarController@getCar');\n")),Object(i.b)("p",null,"When a petition is sent to the ",Object(i.b)("inlineCode",{parentName:"p"},"/cars/{carId}")," endpoint, the Route Manger creates a new instance of the ",Object(i.b)("strong",{parentName:"p"},"CarController")," class using the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," method, which crates all required instances for the injected dependencies in chain."),Object(i.b)("h2",{id:"make-method"},"Make Method"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"make")," methods allows to create instances of any class while creating instances of the dependencies defined in the constructor."),Object(i.b)("h3",{id:"basic-usage"},"Basic Usage"),Object(i.b)("p",null,"When using the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," method, dependency instances are created in a recurring way. That is, if the dependencies have more dependencies, they will also be instantiated when creating them, and so on."),Object(i.b)("p",null,"For instance, let's create an instance of the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"CarController"))," class we defined previously:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Controllers\\CarController;\n\n# Get the container instance\n$container = Sci::instance()->container();\n\n# The CarManager will be injected\n$carController = $container->make(CarController:class);\n\n")),Object(i.b)("p",null,"Please note that the result of ",Object(i.b)("inlineCode",{parentName:"p"},"CarController:class")," statement is ",Object(i.b)("inlineCode",{parentName:"p"},"'MyPlugin\\App\\Controllers\\CarController'"),", so you could also write this code and get the same result:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"\n# The CarManager will be injected\n$carController = $container->make('MyPlugin\\App\\Controllers\\CarController');\n\n")),Object(i.b)("h3",{id:"passing-arguments"},"Passing Arguments"),Object(i.b)("p",null,"You can also send arguments using a second optional parameter of the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," method. The second parameter should be an array with the name of the parameters as the array keys and the arguments as the array values. Let's modify our CarController class accordingly:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"\nnamespace MyPlugin\\App\\Controllers;\n\nuse MyPlugin\\Sci\\Controller;\nuse MyPlugin\\App\\Services\\CarManager;\n\nclass CarController extends Controller\n{\n    # Will contain the CarManager instance\n    protected $carManager;\n\n    # We use type in the CarManager dependency\n    public function __construct($brand, CarManager $carManager)\n    {\n        # The CarManager instance is already created\n        $this->carManager = $carManager;\n    }\n\n    # Use the CarManager to get a car\n    public function getCar($carId)\n    {\n        $car = $this->carManager->get($carId);\n        if ($car) {\n            echo($car->model);\n        }\n    }\n}\n")),Object(i.b)("p",null,"And now imagine that we want to create an instance injecting the required dependencys while sending tha brand as an argument. All you need to do is send the brand in the arguments array:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"# The CarManager will be injected\n$carController = $container->make(CarController:class, ['brand' => 'seat']);\n\n")),Object(i.b)("p",null,"However, if the parameters follow the correct order, you can skip the paramater names:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"# The CarManager will be injected\n$carController = $container->make(CarController:class, ['seat']);\n\n")),Object(i.b)("p",null,"For more parameters, just add more elements to the array."),Object(i.b)("h3",{id:"shortcut-method"},"Shortcut Method"),Object(i.b)("p",null,"There's a short way of invoking the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," method. All you need to do is call the ",Object(i.b)("inlineCode",{parentName:"p"},"make")," static method in the Sci class. Here is an example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Controllers\\CarController;\n\n# The CarManager will be injected\n$carController = Sci::make(CarController:class, ['seat']);\n\n")),Object(i.b)("p",null,"Easy and for all the family :-)"),Object(i.b)("h2",{id:"container-bindings"},"Container Bindings"),Object(i.b)("p",null,"Imagine that you want to quickly replace a dependence with a different implementation. Ideally, the dependence would be referenced with an interface in the constructor so we can easily swap it for a different one. We can achieve this with bindings, and the best place to do this are the providers. "),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note"),": You will just to use bindings when you wan to modify the default container behaviour. You usually don't need to specify the container where to find the dendences or how to build objects."),Object(i.b)("h3",{id:"closure-binding"},"Closure Binding"),Object(i.b)("p",null,"You can use the bind method with a closure where you will return a different instance of the requested class. This is useful when we want o return different implementations."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Services\\Storage;\nuse MyPlugin\\App\\Services\\CarManager;\n\n# Bind the CarManager to a fixed implementation\n$container->bind(CarManager:class, function() {\n\n    if (WP_DEBUG) {\n        return new CarManager(Sci::make(Storage::class, ['dev']));\n    } else {\n        return new CarManager(Sci::make(Storage::class ['production']));\n    }\n});\n\n")),Object(i.b)("p",null,"In the previous exmaple we replace the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"CarManager"))," with a different implementation based on the environment. However, this is usually done in the providers and you wouldn't usually have these condition checks inside the bind method."),Object(i.b)("p",null,"The extended practice is to have two different providers swapping them and returning a single instance inside the binding code"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Services\\Storage;\nuse MyPlugin\\App\\Services\\CarManager;\n\n# Binding the CarManager inside a provider\n$container->bind(CarManager:class, function() {\n    return new CarManager(Sci::make(Storage::class, ['dev']));\n});\n\n")),Object(i.b)("p",null," We will see the providers in depth in the Components section."),Object(i.b)("h3",{id:"singleton-binding"},"Singleton Binding"),Object(i.b)("p",null,"If you want to bind a singleton so there's just one instance of a service in your plugin, you can bind da singleton. You may think that you can just apply the singleton patternt in the service class, and you are right. However, this will just allow to have just one and only one instance, even when you are testing. Ideally, you should define singletons using the ",Object(i.b)("inlineCode",{parentName:"p"},"singleton")," binding method:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Services\\Storage;\nuse MyPlugin\\App\\Services\\CarManager;\n\n# Always return the same instance\n$container->singleton(CarManager:class, function() {\n    return new CarManager(Sci::make(Storage::class, ['dev']));\n});\n\n")),Object(i.b)("p",null,"When using the singleton method, the container will create just one instance of the requested class. The good side of this is that you can always use a different provider and change this behaviour."),Object(i.b)("h3",{id:"instance-binding"},"Instance Binding"),Object(i.b)("p",null,"You can also bind an interface or a class with a specific instance of the class or interface. To do so, you just need create an instance of the class you want to bind and bind the class with the created instance. Here is an example: "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPlugin\\App\\Services\\CarManager;\n\n$carManager = new CarManager();\n\n# Bind the class with the created instance\n$container->bind(CarManager:class, $carManager);\n")),Object(i.b)("h3",{id:"interface-binding"},"Interface Binding"),Object(i.b)("p",null,"Imagine that you want to inject an interface and easily swap it with different implementations. You can also use the ",Object(i.b)("inlineCode",{parentName:"p"},"bind")," method to bind the interface to a specific implementation. For example, this is useful when we want o return different implementations based on any environment variable. Here is an example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"namespace MyPlugin;\n\nuse MyPlugin\\Sci\\Sci;\nuse MyPLugin\\App\\Services\\IMotorService;\nuse MyPLugin\\App\\Services\\MyMotorService;\n\n# Bind the IMotorService interface to the AcmeMotorService implementation\n$container->bind(IMotorService::class, MyMotorService::class);\n")),Object(i.b)("p",null,"Once the interface is binded, everytime the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"IMotorService"))," is requested as an dependency it will always be injected the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"MyMotorService"))," implementation."),Object(i.b)("h2",{id:"container-actions"},"Container Actions"),Object(i.b)("h3",{id:"create-action-oncreate-method-bla"},"Create Action on('create', 'method', 'bla')"),Object(i.b)("h3",{id:"resolve-action-onresolve-method-bla"},"Resolve Action on('resolve', 'method', 'bla')"))}d.isMDXComponent=!0},135:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return h}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),d=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},p=function(e){var n=d(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(t),b=a,h=p["".concat(c,".").concat(b)]||p[b]||u[b]||i;return t?r.a.createElement(h,o({ref:n},l,{components:t})):r.a.createElement(h,o({ref:n},l))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,c=new Array(i);c[0]=b;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,c[1]=o;for(var l=2;l<i;l++)c[l]=t[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);